{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>ZodiPy is an Astropy-affiliated package for simulating  zodiacal light in intensity for arbitrary solar system observers. </p>"},{"location":"#a-simple-example","title":"A simple example","text":"<pre><code>import astropy.units as u\nfrom astropy.coordinates import SkyCoord\nfrom astropy.time import Time\n\nimport zodipy\n\n# Initialize a zodiacal light model at a wavelength/frequency or over a bandpass\nmodel = zodipy.Model(25*u.micron)\n\n# Use Astropy's `SkyCoord` object to specify coordinates\nlon = [10, 10.1, 10.2] * u.deg\nlat = [90, 89, 88] * u.deg\nobstimes = Time([\"2022-01-01 12:00:00\", \"2022-01-01 12:01:00\", \"2022-01-01 12:02:00\"])\nskycoord = SkyCoord(lon, lat, obstime=obstimes, frame=\"galactic\")\n\n# Evaluate the zodiacal light model\nemission = model.evaluate(skycoord)\n\nprint(emission)\n#&gt; [27.52410841 27.66572294 27.81251906] MJy / sr\n</code></pre> <p>For more information on using ZodiPy, see the usage section.</p>"},{"location":"install/","title":"Install","text":"<p>ZodiPy supports python versions &gt;= 3.9.</p> <p>Installing ZodiPy is as simple as:</p> <pre><code>pip install zodipy\n</code></pre>"},{"location":"install/#dependencies","title":"Dependencies","text":"<p>ZodiPy has the following dependencies (these are automatically downloaded when using pip):</p> <ul> <li>Astropy (&gt;= 5.0.1)</li> <li>NumPy</li> <li>jplehem</li> <li>SciPy</li> </ul>"},{"location":"introduction/","title":"Introduction","text":"<p>ZodiPy is a Python package for zodiacal light simulations. Its purpose is to provide the  astrophysics and cosmology communities with an easy-to-use and accessible interface to existing  zodiacal light models in Python, assisting in astrophysical data analysis and zodiacal light  forecasting for future experiments.</p> <p>For other zodiacal light tools, see  Zodiacal Light Models on LAMBDA.</p>"},{"location":"introduction/#supported-zodiacal-light-models","title":"Supported zodiacal light models","text":"<ul> <li>DIRBE [<code>\"dirbe\"</code>] (Kelsall et al. 1998)</li> <li>Rowan-Robinson and May (experimental) [<code>\"rrm-experimental\"</code>] (Rowan-Robinson and May 2013)</li> <li>Planck 2013 [<code>\"planck13\"</code>] (Planck Collaboration et al. 2014)</li> <li>Planck 2015 [<code>\"planck15\"</code>] (Planck Collaboration et al. 2016)</li> <li>Planck 2018 [<code>\"planck18\"</code>] (Planck Collaboration et al. 2020)</li> <li>Odegard [<code>\"odegard\"</code>] (Odegard et al. 2019)</li> </ul> <p>The names in the brackets are the string representations used in the <code>Model</code> object  to select the model.</p> <p>If you see a missing model or wish to add a new one, please feel free to open an issue on GitHub.  Contributors are very welcome!</p>"},{"location":"introduction/#related-scientific-papers","title":"Related scientific papers","text":"<p>See CITATION</p> <ul> <li>Cosmoglobe: Simulating zodiacal emission with ZodiPy (San et al. 2022). </li> <li>ZodiPy: A Python package for zodiacal light simulations (San 2024). </li> </ul>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#zodipy.Model","title":"Model","text":"<pre><code>Model(x, *, weights=None, name='dirbe', gauss_quad_degree=50, extrapolate=False, ephemeris='builtin')\n</code></pre> <p>Main interface to ZodiPy.</p> <p>Initialize a zodiacal light model.</p> PARAMETER DESCRIPTION <code>x</code> <p>Wavelength or frequency. If <code>x</code> is a sequence it is assumed to be a the points corresponding to an instrument bandpass and the corresponding <code>weights</code> argument must be provided.</p> <p> TYPE: <code>Quantity[micron | GHz]</code> </p> <code>weights</code> <p>Bandpass weights corresponding the the frequencies/wavelengths in <code>x</code>. The weights are assumed to represent a normalized instrument response in units of spectral radiance [Jy/sr].</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>name</code> <p>Zodiacal light model to use. See the docs for list of available models. Defaults to 'dirbe'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'dirbe'</code> </p> <code>gauss_quad_degree</code> <p>Order of the Gaussian-legendre quadrature representing the number of discrete points along each line-of-sight. Default is 50 points.</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> <code>extrapolate</code> <p>If <code>True</code> all spectral quantities in the selected model are extrapolated to the requested frequencies/wavelengths. Else, an exception is raised on values of <code>x</code> outside of the valid model range. Default is <code>False</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>ephemeris</code> <p>Ephemeris used in Astropy's <code>solar_system_ephemeris</code> to compute the positions of Earth and optionally the observer. See the Astropy documentation for all available ephemerides. Defaults to 'builtin'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'builtin'</code> </p> Source code in <code>zodipy/model.py</code> <pre><code>def __init__(\n    self,\n    x: units.Quantity[units.micron | units.GHz],\n    *,\n    weights: npt.ArrayLike | None = None,\n    name: str = \"dirbe\",\n    gauss_quad_degree: int = 50,\n    extrapolate: bool = False,\n    ephemeris: str = \"builtin\",\n) -&gt; None:\n    \"\"\"Initialize a zodiacal light model.\n\n    Args:\n        x: Wavelength or frequency. If `x` is a sequence it is assumed to be a the points\n            corresponding to an instrument bandpass and the corresponding `weights` argument\n            must be provided.\n        weights: Bandpass weights corresponding the the frequencies/wavelengths in `x`. The\n            weights are assumed to represent a normalized instrument response in units of\n            spectral radiance [Jy/sr].\n        name: Zodiacal light model to use. See the\n            [docs](https://cosmoglobe.github.io/zodipy/introduction/) for list of available\n            models. Defaults to 'dirbe'.\n        gauss_quad_degree: Order of the Gaussian-legendre quadrature representing the number of\n            discrete points along each line-of-sight. Default is 50 points.\n        extrapolate: If `True` all spectral quantities in the selected model are extrapolated to\n            the requested frequencies/wavelengths. Else, an exception is raised on values of `x`\n            outside of the valid model range. Default is `False`.\n        ephemeris: Ephemeris used in Astropy's `solar_system_ephemeris` to compute the positions\n            of Earth and optionally the observer. See the\n            [Astropy documentation](https://docs.astropy.org/en/stable/coordinates/solarsystem.html)\n            for all available ephemerides. Defaults to 'builtin'.\n\n    \"\"\"\n    try:\n        if not x.isscalar and weights is None:\n            msg = \"Bandpass weights must be provided for non-scalar `x`.\"\n            raise ValueError(msg)\n    except AttributeError as error:\n        msg = \"The input 'x' must be an astropy Quantity.\"\n        raise TypeError(msg) from error\n    if x.isscalar and weights is not None:\n        msg = \"Bandpass weights should not be provided for scalar `x`.\"\n        raise ValueError(msg)\n\n    self._ipd_model = model_registry.get_model(name)\n    if not extrapolate and not self._ipd_model.is_valid_at(x):\n        msg = (\n            \"The requested frequencies are outside the valid range of the model. \"\n            \"If this was intended, set the extrapolate argument to True.\"\n        )\n        raise ValueError(msg)\n\n    # Bandpass is provided rather than a delta wavelength or frequency.\n    if weights is not None:\n        weights = np.asarray(weights)\n        if x.size != weights.size:\n            msg = \"Number of wavelengths and weights must be the same in the bandpass.\"\n            raise ValueError(msg)\n        normalized_weights = weights / integrate.trapezoid(weights, x)\n    else:\n        normalized_weights = None\n\n    self._x = x\n    self._bounds_error = not extrapolate\n    self._normalized_weights = normalized_weights\n    self._b_nu_table = tabulate_blackbody_emission(self._x, self._normalized_weights)\n\n    quad_points, quad_weights = np.polynomial.legendre.leggauss(gauss_quad_degree)\n    self._integrate_leggauss = functools.partial(\n        integrate_leggauss,\n        points=quad_points,\n        weights=quad_weights,\n    )\n\n    self._ephemeris = ephemeris\n\n    # Make mypy happy by declaring types of to-be initialized attributes.\n    self._number_density_partials: dict[ComponentLabel, functools.partial]\n    self._interped_comp_params: dict[ComponentLabel, dict]\n    self._interped_shared_params: dict\n\n    self._init_ipd_model_partials()\n</code></pre>"},{"location":"reference/#zodipy.Model.evaluate","title":"evaluate","text":"<pre><code>evaluate(skycoord, *, obspos='earth', return_comps=False, nprocesses=1)\n</code></pre> <p>Return the simulated zodiacal light.</p> <p>The zodiacal light is simulated for all sky coordinates present in the <code>skycoord</code> argument. If an obstime and obspos value is not provided for each coordinate value, all coordinates are assumed to be observed at an instant from the same position.</p> PARAMETER DESCRIPTION <code>skycoord</code> <p><code>astropy.coordinates.SkyCoord</code> object representing the coordinates for which to simulate the zodiacal light. The <code>obstime</code> attribute must be specified, and correspond to a either a single, or a sequence of observational times, one for each coordinate in <code>skycoord</code>. The coordinate frame, provided through the <code>frame</code> keyword in the the <code>astropy.coordinates.SkyCoord</code> object (defaults to <code>astropy.coordinates.ICRS</code>), must be convertible to the <code>astropy.coordinates.BarycentricMeanEcliptic</code> frame.</p> <p> TYPE: <code>SkyCoord</code> </p> <code>obspos</code> <p>The heliocentric ecliptic position of the observer, or a string representing an observer supported by the <code>astropy.coordinates.solar_system_ephemeris</code>. If an explicit position is given, it must either be a single, or a sequence of positions, one for each coordinate. Defaults to 'earth'.</p> <p> TYPE: <code>Quantity[AU] | str</code> DEFAULT: <code>'earth'</code> </p> <code>return_comps</code> <p>If <code>True</code>, the emission is returned component-wise. Defaults to <code>False</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>nprocesses</code> <p>Number of cores to use. If <code>nprocesses &gt;= 1</code>, the line-of-sight integrals are distributed and computed in parallel using the <code>multiprocessing</code> module. Defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>emission</code> <p>Simulated zodiacal light [MJy/sr].</p> <p> TYPE: <code>Quantity[MJy / sr]</code> </p> Source code in <code>zodipy/model.py</code> <pre><code>def evaluate(\n    self,\n    skycoord: coords.SkyCoord,\n    *,\n    obspos: units.Quantity[units.AU] | str = \"earth\",\n    return_comps: bool = False,\n    nprocesses: int = 1,\n) -&gt; units.Quantity[units.MJy / units.sr]:\n    \"\"\"Return the simulated zodiacal light.\n\n    The zodiacal light is simulated for all sky coordinates present in the `skycoord` argument.\n    If an obstime and obspos value is not provided for each coordinate value, all coordinates\n    are assumed to be observed at an instant from the same position.\n\n    Args:\n        skycoord: `astropy.coordinates.SkyCoord` object representing the coordinates for which\n            to simulate the zodiacal light. The `obstime` attribute must be specified, and\n            correspond to a either a single, or a sequence of observational times, one for each\n            coordinate in `skycoord`. The coordinate frame, provided through the `frame` keyword\n            in the the `astropy.coordinates.SkyCoord` object (defaults to\n            `astropy.coordinates.ICRS`), must be convertible to the\n            `astropy.coordinates.BarycentricMeanEcliptic` frame.\n        obspos: The heliocentric ecliptic position of the observer, or a string representing an\n            observer supported by the `astropy.coordinates.solar_system_ephemeris`. If an\n            explicit position is given, it must either be a single, or a sequence of positions,\n            one for each coordinate. Defaults to 'earth'.\n        return_comps: If `True`, the emission is returned component-wise. Defaults to `False`.\n        nprocesses: Number of cores to use. If `nprocesses &gt;= 1`, the line-of-sight integrals\n            are distributed and computed in parallel using the `multiprocessing` module.\n            Defaults to 1.\n\n    Returns:\n        emission: Simulated zodiacal light [MJy/sr].\n\n    \"\"\"\n    try:\n        if skycoord.obstime is None:\n            msg = \"The `obstime` attribute of the `SkyCoord` object is not set.\"\n            raise ValueError(msg)\n    except AttributeError as error:\n        msg = \"The input coordinates must be an astropy SkyCoord object.\"\n        raise TypeError(msg) from error\n\n    try:\n        if not (obspos_isstr := isinstance(obspos, str)) and (\n            (obspos.ndim &gt; 1 and skycoord.obstime.size != obspos.shape[-1])\n            or (obspos.ndim == 1 and skycoord.obstime.size != 1)\n        ):\n            msg = \"The number of obstime (ncoords) and obspos (3, ncoords) does not match.\"\n            raise ValueError(msg)\n    except AttributeError as error:\n        msg = \"The observer position is not a string or an astropy Quantity.\"\n        raise TypeError(msg) from error\n\n    if skycoord.obstime.size &gt; skycoord.size:\n        msg = \"The size of obstime must be either 1 or ncoords.\"\n        raise ValueError(msg)\n\n    if skycoord.obstime.size == 1:\n        interp_obstimes = None\n    else:\n        interp_obstimes = arrange_obstimes(skycoord.obstime[0].mjd, skycoord.obstime[-1].mjd)\n\n    dist_coords_to_cores = skycoord.size &gt; nprocesses &gt; 1\n    if dist_coords_to_cores:\n        skycoord_splits = np.array_split(skycoord, nprocesses)\n        obspos_splits = (\n            itertools.repeat(obspos, nprocesses)\n            if obspos_isstr\n            else np.array_split(obspos, nprocesses, axis=-1)\n        )\n        interp_obstime_splits = itertools.repeat(interp_obstimes, nprocesses)\n        with multiprocessing.get_context(PLATFORM_METHOD).Pool(nprocesses) as pool:\n            emission_splits = [\n                pool.apply_async(self._evaluate, args=(skycoord, obspos, obstime_lims))\n                for skycoord, obspos, obstime_lims in zip(\n                    skycoord_splits, obspos_splits, interp_obstime_splits\n                )\n            ]\n            emission = np.concatenate([split.get() for split in emission_splits], axis=-1)\n    else:\n        emission = self._evaluate(skycoord, obspos, interp_obstimes)\n\n    emission &lt;&lt;= units.MJy / units.sr\n    return emission if return_comps else emission.sum(axis=0)\n</code></pre>"},{"location":"reference/#zodipy.Model.get_parameters","title":"get_parameters","text":"<pre><code>get_parameters()\n</code></pre> <p>Return a dictionary containing the zodiacal light model parameters.</p> RETURNS DESCRIPTION <code>parameters</code> <p>Zodiacal light model parameter dict.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>zodipy/model.py</code> <pre><code>def get_parameters(self) -&gt; dict:\n    \"\"\"Return a dictionary containing the zodiacal light model parameters.\n\n    Returns:\n        parameters: Zodiacal light model parameter dict.\n    \"\"\"\n    return self._ipd_model.to_dict()\n</code></pre>"},{"location":"reference/#zodipy.Model.update_parameters","title":"update_parameters","text":"<pre><code>update_parameters(parameters)\n</code></pre> <p>Update the zodiacal light model parameters from a parameter dictionary.</p> <p>The structure of the input dictionary must match that of the output of the <code>get_parameters</code> method.</p> PARAMETER DESCRIPTION <code>parameters</code> <p>Zodiacal light model parameter dict.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>zodipy/model.py</code> <pre><code>def update_parameters(self, parameters: dict) -&gt; None:\n    \"\"\"Update the zodiacal light model parameters from a parameter dictionary.\n\n    The structure of the input dictionary must match that of the output of the `get_parameters`\n    method.\n\n    Args:\n        parameters: Zodiacal light model parameter dict.\n\n    \"\"\"\n    _dict = parameters.copy()\n    _dict[\"comps\"] = {}\n    for key, value in parameters.items():\n        if key == \"comps\":\n            for comp_key, comp_value in value.items():\n                _dict[\"comps\"][ComponentLabel(comp_key)] = type(\n                    self._ipd_model.comps[ComponentLabel(comp_key)]\n                )(**comp_value)\n        elif isinstance(value, dict):\n            _dict[key] = {ComponentLabel(k): v for k, v in value.items()}\n\n    self._ipd_model = self._ipd_model.__class__(**_dict)\n    self._init_ipd_model_partials()\n</code></pre>"},{"location":"reference/#zodipy.grid_number_density","title":"grid_number_density","text":"<pre><code>grid_number_density(x, y, z, obstime, model='dirbe', ephemeris='builtin')\n</code></pre> <p>Return the component-wise tabulated densities of the zodiacal components for a given grid.</p> PARAMETER DESCRIPTION <code>x</code> <p>x-coordinates of a cartesian mesh grid.</p> <p> TYPE: <code>Quantity[AU]</code> </p> <code>y</code> <p>y-coordinates of a cartesian mesh grid.</p> <p> TYPE: <code>Quantity[AU]</code> </p> <code>z</code> <p>z-coordinates of a cartesian mesh grid.</p> <p> TYPE: <code>Quantity[AU]</code> </p> <code>obstime</code> <p>Time of observation. Required to compute the Earth position.</p> <p> TYPE: <code>Time</code> </p> <code>model</code> <p>String representing a built-in model or an explicit instance of a <code>ZodiacalLightModel</code>. Default is 'dirbe'.</p> <p> TYPE: <code>str | ZodiacalLightModel</code> DEFAULT: <code>'dirbe'</code> </p> <code>ephemeris</code> <p>Solar system ephemeris to use. Default is 'builtin'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'builtin'</code> </p> RETURNS DESCRIPTION <code>number_density_grid</code> <p>The tabulated zodiacal component densities.</p> <p> TYPE: <code>NDArray[float64]</code> </p> Source code in <code>zodipy/number_density.py</code> <pre><code>def grid_number_density(\n    x: units.Quantity[units.AU],\n    y: units.Quantity[units.AU],\n    z: units.Quantity[units.AU],\n    obstime: time.Time,\n    model: str | ZodiacalLightModel = \"dirbe\",\n    ephemeris: str = \"builtin\",\n) -&gt; npt.NDArray[np.float64]:\n    \"\"\"Return the component-wise tabulated densities of the zodiacal components for a given grid.\n\n    Args:\n        x: x-coordinates of a cartesian mesh grid.\n        y: y-coordinates of a cartesian mesh grid.\n        z: z-coordinates of a cartesian mesh grid.\n        obstime: Time of observation. Required to compute the Earth position.\n        model: String representing a built-in model or an explicit instance of a\n            `ZodiacalLightModel`. Default is 'dirbe'.\n        ephemeris: Solar system ephemeris to use. Default is 'builtin'.\n\n    Returns:\n        number_density_grid: The tabulated zodiacal component densities.\n\n    \"\"\"\n    if isinstance(model, str):\n        zodiacal_light_model = model_registry.get_model(model)\n    elif isinstance(model, ZodiacalLightModel):\n        zodiacal_light_model = model\n    else:\n        msg = \"model type must be a `str` or a `ZodiacalLightModel`.\"\n        raise TypeError(msg)\n\n    grid = np.asarray(np.meshgrid(x, y, z))\n\n    earthpos_xyz = get_earthpos_inst(obstime, ephemeris=ephemeris)\n\n    # broadcasting reshapes\n    for comp in zodiacal_light_model.comps.values():\n        comp.X_0 = comp.X_0.reshape(3, 1, 1, 1)\n\n    density_partials = get_partial_number_density_func(\n        comps=zodiacal_light_model.comps,\n    )\n    density_partials = update_partial_earth_pos(\n        density_partials, earthpos_xyz[:, np.newaxis, np.newaxis, np.newaxis]\n    )\n\n    number_density_grid = np.zeros((len(zodiacal_light_model.comps), *grid.shape[1:]))\n    for idx, number_density_callable in enumerate(density_partials.values()):\n        number_density_grid[idx] = number_density_callable(grid)\n\n    # Revert broadcasting reshapes\n    for comp in zodiacal_light_model.comps.values():\n        comp.X_0 = comp.X_0.reshape(3, 1)\n\n    return number_density_grid\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>Breaking API changes in <code>v1.0.0</code></p> <p>In version <code>v1.0.0</code> the <code>get_emission_*</code> and <code>get_binned_emission_*</code> methods were deprecated  and removed. Users wanting to simulate zodiacal light directly from HEALPix pixel indices should see the HEALPix section under examples.</p> <p>As an Astropy-affiliated package, ZodiPy is highly integrated with the Astropy ecosystem,  particularly with the <code>astropy.units</code>,  <code>astropy.coordinates</code>, and  <code>astropy.time</code> modules.</p>"},{"location":"usage/#initializing-a-zodiacal-light-model","title":"Initializing a zodiacal light model","text":"<p>To make zodiacal light simulations we must first import and initialize a zodiacal light model <pre><code>import astropy.units as u\nimport zodipy\n\nmodel = zodipy.Model(25 * u.micron)\n</code></pre> The <code>zodipy.Model</code> object has one required positional argument, <code>x</code>, which can  either represent a center wavelength/frequency or the points of an empirical bandpass. If <code>x</code>  represents the points of an instrument bandpass, the <code>weights</code> argument must also be provided <pre><code>import astropy.units as u\nimport zodipy\n\npoints = [3, 4, 5, 6] * u.micron\nweights = [0.2, 0.4, 0.3, 0.1]\n\nmodel = zodipy.Model(points, weights=weights)\n</code></pre></p> <p>ZodiPy supports several zodiacal light models valid at different  wavelength/frequency ranges. By default, a <code>Model</code> will initialize on the  DIRBE model. To select another  model, for instance the Planck 2013 model , we need to specify the <code>name</code> keyword in the model constructor <pre><code>import astropy.units as u\nimport zodipy\n\nmodel = zodipy.Model(25 * u.micron, name=\"planck13\")\n</code></pre></p> <p>Other possible keyword arguments to the <code>zodipy.Model</code> are <code>gauss_quad_degree</code>,  which determines the number of discrete points evaluated along each line-of-sight, <code>extrapolate</code>,  which, if set to <code>True</code>, uses linear interpolation to extrapolate the frequency/wavelength dependent  model parameters allowing the model to be evaluated outside of it's original bounds, and finally,  <code>ephemeris</code>, which one can use to specify the solar system ephemeris. used to  compute the position of the Earth and optionally the observer.</p>"},{"location":"usage/#evaluating-a-zodiacal-light-model","title":"Evaluating a zodiacal light model","text":"<p>To make zodiacal light simulations ZodiPy needs some inputs data from the user:</p> <ol> <li>Sky coordinates. Provided through Astropy's  <code>SkyCoord</code> object.</li> <li>Time of observeration(s). Also provided in the  <code>SkyCoord</code> object.</li> <li>Position(s) of the observer. Provided in a separate argument when evaluating the model.</li> </ol>"},{"location":"usage/#the-skycoord-object","title":"The <code>SkyCoord</code> object","text":"<p>Users unfamiliar with Astropy's  <code>SkyCoord</code> should first  visit the official Astropy docs to learn the basics.</p> <p>For a single observation in galactic coordinates, the  <code>SkyCoord</code> object may  look something like the following: <pre><code>import astropy.units as u\nfrom astropy.coordinates import SkyCoord\nfrom astropy.time import Time\n\nskycoord = SkyCoord(\n    40 * u.deg, \n    60 * u.deg, \n    obstime=Time(\"2020-01-01\"), \n)\n</code></pre> where the coordinates here are specified as longitude and latitude values. Note that the  <code>SkyCoord</code> object is very  flexible and supports many  different formats for the coordinates.</p> <p>The <code>obstime</code> keyword is mandatory and is given by the Astropy  <code>Time</code> object, which can  represent time in many formats, including regular and modified Julian dates (see the   <code>Time</code> docs for more information).</p> <p>For several observations, each with their own <code>obstime</code> input, the  <code>SkyCoord</code> may instead look like the following: <pre><code>import astropy.units as u\nfrom astropy.coordinates import SkyCoord\nfrom astropy.time import Time\n\nskycoord = SkyCoord(\n    [40, 41, 42] * u.deg, \n    [60, 59, 58] * u.deg, \n    obstime=Time([\"2020-01-01\", \"2020-01-02\", \"2020-01-03\"]), \n)\n</code></pre> If a single value is given for <code>obstime</code>, all coordinates are assumed to be viewed instantaneously  at that time from a single position in the solar system. Otherwise, each coordinate must have its  own <code>obstime</code> value.</p> <p>The sky coordinates should represent observer-centric coordinates. The observer-position is  therefore required to compute the line-of-sight integrals, but this is provided not in the  <code>SkyCoord</code> object, but  rather in the <code>evaluate</code> method, which we will see soon.</p> <p>The coordinate frame in the  <code>SkyCoord</code> object  defaults to the <code>ICRS</code> frame,  but can be changed by providing the <code>frame</code> keyword argument: <pre><code>import astropy.units as u\nfrom astropy.coordinates import SkyCoord\nfrom astropy.time import Time\n\nskycoord = SkyCoord(\n    [40, 41, 42] * u.deg, \n    [60, 59, 58] * u.deg, \n    obstime=Time([\"2020-01-01\", \"2020-01-02\", \"2020-01-03\"]), \n    frame=\"galactic\",\n)\n</code></pre></p> <p>Common coordinate frames are the Ecliptic, Galactic, and Celestial frames (these are represented as  \"E\", \"G\", \"C\" in <code>healpy</code>), which can be specified  either through string representations:</p> <ul> <li><code>\"barycentricmeanecliptic\"</code> (Ecliptic)</li> <li><code>\"galactic\"</code> (Galactic)</li> <li><code>\"icrs\"</code> (Celestial)</li> </ul> <p>or through frame objects imported from <code>astropy.coordinates</code>:</p> <ul> <li><code>BarycentricMeanEcliptic</code></li> <li><code>Galactic</code></li> <li><code>ICRS</code></li> </ul> <p>Notes on coordinate frames</p> <p>Note that these built-in Astropy frames do not inherently represent observer-centric coordinate  frames. However this is fine, since we only need to know the rotation of the coordinates with  respect to the ecliptic plane (internally, the coordinates are manually shifted to heliocentric  coordinates using the <code>obspos</code> value)-</p>"},{"location":"usage/#the-evaluate-method","title":"The <code>evaluate</code> method","text":"<p>The zodiacal light is evaluated by providing the  <code>SkyCoord</code> object to the  <code>evaluate</code> method.</p> <p><pre><code>import astropy.units as u\nfrom astropy.coordinates import SkyCoord\nfrom astropy.time import Time\nimport zodipy\n\nmodel = zodipy.Model(25 * u.micron)\n\nskycoord = SkyCoord(\n    40 * u.deg, \n    60 * u.deg, \n    obstime=Time(\"2020-01-01\"), \n    frame=\"galactic\"\n)\n\nemission = model.evaluate(skycoord)\nprint(emission)\n# &lt;Quantity [25.08189292] MJy / sr&gt;\n</code></pre> By default, the observer is assumed to be the center of the Earth. In this case the Earth position is  computed internally using Astropy's  solar system ephemeris.  The position of the observer can be explicitly provided through the keyword argument <code>obspos</code> in the  <code>evaluate</code> method</p> <p><pre><code>import astropy.units as u\nfrom astropy.coordinates import SkyCoord\nfrom astropy.time import Time\nimport zodipy\n\nmodel = zodipy.Model(25 * u.micron)\n\nskycoord = SkyCoord(\n    40 * u.deg, \n    60 * u.deg, \n    obstime=Time(\"2020-01-01\"), \n    frame=\"galactic\"\n)\n\nemission = model.evaluate(skycoord, obspos=\"mars\")\nprint(emission)\n# &lt;Quantity [8.36985535] MJy / sr&gt;\n\nemission = model.evaluate(skycoord, obspos=[0.87, -0.53, 0.001] * u.AU)\nprint(emission)\n# &lt;Quantity [20.37750965] MJy / sr&gt;\n</code></pre> This argument accepts both a string representing a body recognized by the  solar system ephemeris, or a  heliocentric ecliptic cartesian position.</p> <p>Similar to with the <code>obstime</code> attribute in the  <code>SkyCoord</code> object, the  value provided to the <code>obspos</code> keyword must have shape <code>(3,)</code> or <code>(3, ncoords)</code>, where <code>ncoords</code> is  the number of coordinates in the  <code>SkyCoord</code> object. </p>"},{"location":"usage/#multiprocessing","title":"Multiprocessing","text":"<p>ZodiPy will distribute the input coordinates to available cores using Python's  <code>multiprocessing</code> module if the keyword  argument <code>nprocesses</code> in the <code>evaluate</code> method is greater or equal to 1.</p> <pre><code>import multiprocessing\n\nnprocesses = multiprocessing.cpu_count() # 8 cores\n\nemission = model.evaluate(skycoord, nprocesses=nprocesses)\n</code></pre>"},{"location":"usage/#examples","title":"Examples","text":""},{"location":"usage/#zodiacal-light-along-an-ecliptic-scan","title":"Zodiacal light along an Ecliptic scan","text":"<p>In the following, we simulate a scan across the Ecliptic plane:</p> ecliptic_scan.py<pre><code>import astropy.units as u\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom astropy.coordinates import BarycentricMeanEcliptic, SkyCoord\nfrom astropy.time import Time, TimeDelta\n\nfrom zodipy import Model\n\nmodel = Model(30 * u.micron)\n\nlats = np.linspace(-90, 90, 100) * u.deg\nlons = np.zeros_like(lats)\n\nt0 = Time(\"2022-06-14\")\ndt = TimeDelta(1, format=\"sec\")\nobstimes = t0 + np.arange(lats.size) * dt\n\ncoords = SkyCoord(\n    lons,\n    lats,\n    frame=BarycentricMeanEcliptic,\n    obstime=obstimes,\n)\n\nemission = model.evaluate(coords)\n\nplt.plot(lats, emission)\nplt.xlabel(\"Latitude [deg]\")\nplt.ylabel(\"Emission [MJy/sr]\")\nplt.savefig(\"../img/ecliptic_scan.png\", dpi=300, bbox_inches=\"tight\")\nplt.show()\n</code></pre> <p></p>"},{"location":"usage/#healpix","title":"HEALPix","text":"<p>We can use healpy or  Astropy-healpix to create a  <code>SkyCoord</code> object  directly from a HEALPix pixelization. In the following two examples, we produce an instantaneous map  of the sky in HEALPix representation:</p> healpyastropy-healpix <pre><code>import multiprocessing\n\nimport astropy.units as u\nimport healpy as hp\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom astropy.coordinates import SkyCoord\nfrom astropy.time import Time\n\nimport zodipy\n\nmodel = zodipy.Model(30 * u.micron)\n\nnside = 256\npixels = np.arange(hp.nside2npix(nside))\nlon, lat = hp.pix2ang(nside, pixels, lonlat=True)\n\nskycoord = SkyCoord(lon, lat, unit=u.deg, frame=\"galactic\", obstime=Time(\"2022-01-14\"))\n\nemission = model.evaluate(skycoord, nprocesses=multiprocessing.cpu_count())\n\nhp.mollview(\n    emission,\n    unit=\"MJy/sr\",\n    cmap=\"afmhot\",\n    min=0,\n    max=80,\n    title=\"Zodiacal light at 30 \u00b5m (2022-01-14)\",\n)\nplt.savefig(\"../img/healpix_map.png\", dpi=300, bbox_inches=\"tight\")\nplt.show()\n</code></pre> <pre><code>import multiprocessing\n\nimport astropy.units as u\nimport astropy_healpix as ahp\nimport healpy as hp\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom astropy.time import Time\n\nimport zodipy\n\nmodel = zodipy.Model(30 * u.micron)\n\nhealpix = ahp.HEALPix(nside=256, frame=\"galactic\")\npixels = np.arange(healpix.npix)\nskycoord = healpix.healpix_to_skycoord(pixels)\n\n# Note that we manually set the obstime attribute\nskycoord.obstime = Time(\"2022-01-14\")\n\nemission = model.evaluate(skycoord, nprocesses=multiprocessing.cpu_count())\n\n# Plot with healpy\nhp.mollview(\n    emission,\n    unit=\"MJy/sr\",\n    cmap=\"afmhot\",\n    min=0,\n    max=80,\n    title=\"Zodiacal light at 30 \u00b5m (2022-01-14)\",\n)\n# plt.savefig(\"../img/healpix_map.png\", dpi=300, bbox_inches=\"tight\")\nplt.show()\n</code></pre> <p></p>"},{"location":"usage/#component-wise-zodiacal-light","title":"Component-wise zodiacal light","text":"<p>We can return the zodiacal light for each component by using setting the keyword argument  <code>return_comps</code> to <code>True</code> in the <code>evaluate</code> method: component_maps.py<pre><code>import multiprocessing\n\nimport astropy.units as u\nimport healpy as hp\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom astropy.coordinates import SkyCoord\nfrom astropy.time import Time\n\nimport zodipy\n\nCOMP_NAMES = [\n    \"Smooth cloud\",\n    \"Dust band 1\",\n    \"Dust band 2\",\n    \"Dust band 3\",\n    \"Circum-solar Ring\",\n    \"Earth-trailing Feature\",\n]\n\nmodel = zodipy.Model(24 * u.micron)\n\nnside = 128\npixels = np.arange(hp.nside2npix(nside))\nlon, lat = hp.pix2ang(nside, pixels, lonlat=True)\n\nskycoord = SkyCoord(\n    lon,\n    lat,\n    unit=u.deg,\n    frame=\"barycentricmeanecliptic\",\n    obstime=Time(\"2022-01-14\"),\n)\n\nemission = model.evaluate(skycoord, return_comps=True, nprocesses=multiprocessing.cpu_count())\n\nfig = plt.figure(figsize=(8, 7))\nfor idx, comp_emission in enumerate(emission):\n    hp.mollview(\n        comp_emission,\n        title=COMP_NAMES[idx],\n        norm=\"log\" if idx == 0 else None,\n        cmap=\"afmhot\",\n        cbar=False,\n        sub=(3, 2, idx + 1),\n        fig=fig,\n    )\nplt.savefig(\"../img/component_maps.png\", dpi=250, bbox_inches=\"tight\")\nplt.show()\n</code></pre></p> <p></p>"},{"location":"usage/#visualizing-the-interplanetary-dust-distribution","title":"Visualizing the interplanetary dust distribution","text":"<p>We can visualize the number density of a supported zodiacal light model by using the  <code>grid_number_density</code> function number_density.py<pre><code>import astropy.units as u\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom astropy.time import Time\nfrom matplotlib.colors import LogNorm\n\nfrom zodipy import grid_number_density\n\nN = 200\n\nx = np.linspace(-5, 5, N) * u.AU  # x-plane\ny = np.linspace(-5, 5, N) * u.AU  # y-plane\nz = np.linspace(-2, 2, N) * u.AU  # z-plane\n\ndensity_grid = grid_number_density(\n    x,\n    y,\n    z,\n    obstime=Time(\"2021-01-01T00:00:00\", scale=\"utc\"),\n    model=\"DIRBE\",\n)\ndensity_grid = density_grid.sum(axis=0)  # Sum over all components\n\nplt.pcolormesh(\n    x,\n    y,\n    density_grid[N // 2].T,  # cross section in the yz-plane\n    cmap=\"afmhot\",\n    norm=LogNorm(vmin=density_grid.min(), vmax=density_grid.max()),\n    shading=\"gouraud\",\n    rasterized=True,\n)\nplt.title(\"Cross section of the number density in the DIRBE model\")\nplt.xlabel(\"x [AU]\")\nplt.ylabel(\"z [AU]\")\nplt.savefig(\"../img/number_density.png\", dpi=300, bbox_inches=\"tight\")\nplt.show()\n</code></pre></p> <p></p>"}]}